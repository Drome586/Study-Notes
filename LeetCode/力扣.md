# 力扣疑难点

## 代码随想录

### 数组操作

**数组，List，Map，Set之间的相互转换**

```java
int[] re = ...
List<> res = 
//转换成List
    Arrays.asList(re);//不能修改结构只能查找
	new ArrayList<>(Arrays.asList)//这种的都可以
        
//List转换成数组
    res.toArray()//不推荐，转换成Object类型
    res.toArray(new int[])// 推荐
//List --> set
        addAll
        目的去重
//set --> List
        addAll
        目的排序
```

### LinkedList 和ArrayList

```java
ArrayList：
    add()											增加一个元素
    add(index,e)									在指定位置增加元素
    addAll()										增加一组元素
    remove(index)或者remove("知道的值")
    
    for(int i = 0;i < Arraylist.size();i++){		遍历
        System.out.pringln(ArrayList.get(i))
    }
	
	ArrayList.toArray();
	ArrayList.toArray(new String[]{})				转数组
    
    list.isEmpty()
    list.contains("1")								是否包含"1"
    list.subList(0,3)								截取0-3的位置
    list.indexOf("1")								"1"的索引位置
        
```

```java
LinkedList:
	addFirst()			在链表开头增加元素
    addLast()			在链表结尾增加元素
    offer()				将指定元素增加到链表的结尾
    removeFirst()		删除链表的第一个元素
    removeLast()		删除链表的最后一个元素
    
```

### Queue

```java
offer()			指定元素加到链表的结尾
peek()			找到但不删除链表的头
poll()			找到并删除链表的头
remove()		检索并移除表头
```



### Map

```java
//添加操作
map.put(key,value);
//删除操作
map.remove(key);

//查询操作
map.containsKey(key);
map.get(key);

//修改  key1替换为key2
map.replace(key1,key2);

//遍历所有的key
Set set = map.keySet()
for(Object obj:set){
}

//遍历所有的value
map.values();

//遍历键值对
map.entrySet();

//初始化键值对
Map<Character,Integer> map = new HashMap<>(){
    {
        put('a',1);
        put('b',2);
    }
}

//Map.getOrDefault(key,默认值)

Map中会存储一一对应的key和value。
如果 在Map中存在key，则返回key所对应的的value。
如果 在Map中不存在key，则返回默认值。
    
//返回键值对的数量,也可以判断map是否为空
    
map.size()

//从0开始的for循环，map添加出现元素的次数
for(int i = 0;i < nums.length;i++){
    map.put(nums[i],map.getOrDefault(nums[i],0) + 1);
}
```

### 堆跟优先队列

```java
//堆		完全二叉树   按照层序遍历的方式用一维数组表示
//在一维数组中，父节点为i  左节点2i+1	  右节点2i+2


//新建一个优先级队列，小根堆；将键值对加入到优先级队列中；
//存储的是一个数组，里面放(key,value)
//(pair1,pair2)->pair1[1]-pair2[1] 定义的比较器；默认是升序排列的；下面的有比较器的举例；
PriorityQueue<int[]> que = new PriorityQueue<>((pair1,pair2)->pair1[1]-pair2[1]); //加入的是键值对；
PriorityQueue<int[]> que = new PriorityQueue<>((pair1,pair2)->pair2[1]-pair1[1]); //按照降序排列

返回前k个高频元素
PriorityQueue<int[]> que = new PriorityQueue<>((pair1,pair2)->pair2[1]-pair1[1]);
//遍历map
for(map.Entry(Integer,Integer) entry:map.entrySet()){
    que.add(new int[]{entry.getKey,entry.getValue});
}
int[] ans = new int[k];
for(int i = 0;i < k;i++){
    ans[i] = que.poll()[0];
}
return ans;
```

#### KMP算法

```java
主要是求next数组
//例如	“google”
```

#### String与Int转换

```java
//字符串转数字；包装类parseXXX()
String str = "456";
int a = Integer.parseInt(str)   456
int b = Integer.parseDouble(str)  456.0
    
int c = str.charAt(0) - '0'   4
    
//数字转为字符串
Integer a1 = 123;
int a2 = 456;

//首选既可以用于包装类又可以用于基本数据类型
String str = String.valueOf(a1);

String str = a1 + "";

//toString()只能用于包装类
String  srt = a1.toString(); "123"

```

### 数组

##### **27.	移除元素**：

​		<img src="力扣.assets/image-20230728104445853.png" alt="image-20230728104445853" style="zoom:80%;" />

```java
//1.	可以直接使用暴力算法，不修改原数组，碰到一样的后面的持续往前移动就行
//2.	双指针算法，
int slow = 0;
for(int i = 0;i < nums.length;i++){
    if(nums[i] != val){
        nums[slow++] = nums[i];
    }
    return slow;
}
```



##### **209.	长度最小的子数组**：

​	<img src="力扣.assets/image-20230728112838620.png" alt="image-20230728112838620" style="zoom:80%;" />

```java
//1.	滑动窗口，不管怎么样都是两个while循环
while(right < nums.length){
    sum += nums[right];
    right++;
    
    while(sum > target){
        result = Math.min(result,right-left);
        sum -= nums[left++];
    }
}
return ...
```

##### **3.螺旋矩阵**：（给定一个数n，返回n*n矩阵）

​		1.while循环体中是loop++ < n / 2；for循环中的终止条件是j < n -loop;

### 链表

##### **1.移除链表元素**：

​		1.首先设置头指针

​		2.设置pre跟cur，永远记住pre跟cur只是两个指针。

##### **2.设计链表**：

​		1.查找指定index的元素时，通过：

```java
for(int i = 0;i <= index;i++){
    cur = cur.next;
}
```

​		2.并且涉及到查找等，都要设置 ListNode cur = head;

​		3.双向链表的添加：先1,3再2,4。先确定好添加节点的前后指针。

<img src="力扣.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54qA54mb6LaF5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img" style="zoom: 67%;" />

****

**3.反转链表**

​		1.涉及到交换元素，必须要设置一个临时变量temp=null；

​		2.将设置一个空链表pre=null，然后将head链表取出头一个节点加入pre，最后返回pre。

**4.两两交换链表中的元素**：

​		1.主要找到最后两个元素，然后进行递归交换

```java
(条件)
ListNode next = head.next;
ListNode temp = swap(next.next);
```

**5.删除倒数第n个节点的值**

​		1.设置快慢指针，利用快慢之间的差等于n来判断，当快指针走到链表结束的时候，慢指针所在的位置就是要删除的倒数第n个节点

​		2.设置头结点。

**6.链表相交**	

​		1.短的链表一直走，走到头再去走长的，长的再走，走到头在走短的，这样两者有共同节点必定会相遇，没有共同节点的话也必定会			同时指向null

```java
//赋值语句，先是pA == null ? headB:pA.next，之后才是赋值给pA。
pA = pA == null ? headB:pA.next;
```

### 哈希表

**1.快乐数**

​		1.设置一个HashSet集合，防止计算之后还是n陷入死循环。

​		2.声明一个计算的方法。

**2.四数之和**：

​		1.用一个Map就够，存放数字和出现和的次数。

### 字符串

**1.找出第一个匹配的下标**

​		1.可以用定义好的接口

```java
return 寻找.indexOf(被寻找)
```

**2.反转字符串中的单词**

​		1.如果是包含空格的String，去反转每个单词,如何去找到空格之前的单词

```java
int start = 0
end = start + 1;
while(start < end){
	while(start < end && end != ' ');
		end++;
}
```

### 二叉树

​	1.**如果递归逻辑汇中传入的是左右子树，例如root.left/root.right，那么递归的终止条件来判断root即可。**

​	2.**前序求深度，后续求高度**

​	3.**如果判断条件中有root == null，紧挨着下面的判断条件中还有root.left == null 或者root.right == null,说明节点就走到root  （路径总和）。**

​	4.**前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。**

​	**那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了**。

​	5.**如果要返回某一个节点的父节点，紧挨着的，是要用后序遍历，递归返回条件是return root，因为递归公式中是传入的子树，子树条件符合那么直接返回了他的父节点**

##### **1.反转二叉树**：

​		1.设计一个用来反转树的方法。

##### **2.对称二叉树**

​		1.判断左子树的左节点和右子树的右节点。

​		2.判断左子树的右节点和右子树的左节点。

##### **3.最小深度**

```java
//比最大深度多了两个if判断条件
if(root.left == null) return rightDepth+1;
if(root.right == null) return leftDepth + 1;
return Math.min(leftDepth,rightDepth) + 1;
```

##### **4.平衡二叉树、最大深度、最小深度、完全二叉树节点个数模板**

```java
if(root == null) return 0;
int left = method(root.left);
//具体逻辑
int right = method(root.right);
//具体逻辑
return Math.max/min(left,right) + 1;
```

##### **5.二叉树的路径遍历**

​		1.中左右

​		2.回溯思想

```java
search()
path.add(root)
if(root.left == null && root.right == null)
   	result.add()
if(root.left != null)
    search();
	path.remove()
if(root.right != null)
    search();
	path.remove()
```

##### **6.左叶子之和**

​		1.重点是如何找到左叶子（左右中，不管怎么先把递归的遍历顺序找出来）

```java
if(root.left != null && root.left.left == null && root.left.right == null)//表示通过父节点找到左叶子节点
```

##### **7.找左叶子节点**

​		1.用层序遍历简单，把之前的层序遍历节点稍作改动，while（len>0)改成for循环，目的是利用i == 0找第一个弹出的值

```java
for(int i = 0;i < len;i++){
    if(i == 0){
        res = temp.val;//不断的更新每一层第一个节点值。
    }
}
```

##### **8.路径总和**

​		1.按照减法，将目标和依次递减走过的节点。

```java
//三种情况
targetSum -= root.val
1.if(root.left == null && root.right == null)
2.if(root.left != null)
3.if(root.right != null)
```

##### **9.合并两个二叉树**

​		1.注意在一个二叉树（root1）上重复操作，最终返回这一棵二叉树即可。

#### 二叉搜索树（中序遍历为有序序列）

##### **1.是否为二叉搜索树**（二插搜索树中的最小绝对差）

​		1.空树也是二叉搜索树。

​		2.双指针解法：重点是怎么去赋值当前节点的前一个节点。

```java
//定义一个TreeNode指针 默认为空
TreeNode pre;
//这里写的是递归函数，刚开始一直递归到左子树的最后一个节点，if第一次不执行，正好将root的值赋给pre
if(pre != null && pre.val >= root.val){
    return false;
}
pre = root;

```

##### **2.平衡二叉树的众数(中序遍历）**

​		1.一个是计数：

```java
//双指针，pre是前一个指针
TreeNode pre;
if(pre == null || pre.val != root.val){//第一次出现的节点和不相等的节点的count次数都是1
    count = 1;
}else(pre.val == root.val){
    count++;
}
```

​		2.计算出现最多的

```java
if(count == maxCount){
    result.add(root.val);
}else if(count > maxCount){
    result.clear();
    result.add(root.val);
    maxCount = count;
}
```

##### **3.二叉树的公共祖先**

​		1.后续遍历（单个节点也是自己的公共祖先）

```java
if(root.left != null && root.right == null) return left;//左子树找到了，右子树没找到，返回该节点
if(root.left == null && root.right != null) return right;//同上
```

##### **4.二插树的修剪，涉及到删除的，条件都是return null**

#### 后序

##### 652.寻找重复的子树

​	<img src="力扣.assets/image-20230605103110778.png" alt="image-20230605103110778" style="zoom:80%;" />

（用到了序列化子树，换句话说，一旦发现题目跟子树有关，那大概率要给函数设置合理的定义和返回值，在后续位置写代码）

```java
//1.	寻找重复的子树，那当前结点的子树长什么样子？其他子树的节点是长什么样子？只有知道这两点，才能判断重复的子树是啥
//2.	如何知道子树长什么样子？需要用什么去保存子树的样子？ 
//3.	序列化子树，用Map来保存，采用后序遍历

String traverse(TreeNode root){
    if(root == null) return "";
    String left = traverse(root.left);
    String right = traverse(root.right);
    //查看子树长啥样子
    String subTree = left + "," + right +"," + root.val;//这个顺序无所谓
    //子树出现的次数
    int freq = map.getOrDefault(subTree,0)
    //为什么是==1就可以呢？因为只要map中有过一次的记录就说明这个节点是重复的，不用管重复几次一定是重复的，直接将root节点加入到结果集就可以了。
 	if(freq == 1){
        //加入的是根节点
        result.add(root);
    }
    map.put(subTree,map.getOrDefault(subTree,0) + 1);
    return subTree;
}

```

#### 序列化

##### 剑指offer37

```java
//1.	什么样的序列化的数据可以反序列化出一棵二叉树？只给定前序遍历结果能行吗？只给定后序遍历结果能行吗？比如[1,2,3,4,5]
//2.	答案是不可以的，因为没有空指针信息，如果包含了空指针信息的话就能够确定一棵二叉树（除了中序遍历），例如将上面改成 [1,2,3,#,#,4,#,#,5,#,#]，或者是不给你空指针信息，给你两种遍历顺序，前序和中序，中序和后续都可以还原二叉树
//3.	题目的返回值是什么？序列化是将树转化成字符串，反序列化是将字符串转化成序列
//4.	该用什么方式去遍历？给你一个数组，你该怎么让他变成含有空节点的字符串

String SEP = ",";	//确定分隔符
String NULL = "#";	//需要定义空节点
void serialize(TreeNode root,StringBuilder sb){
    if(root == null){
        sb.append(NULL).append(SEP);
    }
    sb.append(root.val).append(SEP);
    serialize(root.left，sb);
    serialize(root.right,sb);
     
}

//反序列化
public TreeNode deserialize(String data) {
    LinkedList<String> nodes = new LinkedList<>();
    //二刷的时候，split没搞明白"1,2,3" --> [1,2,3],还有怎么将字符串转为TreeNode形式
    for(String s: data.split(SEP)){
        nodes.addLast(s);
    }
    return deserialize(nodes);
}
//	二刷的时候传入什么样的参数不明白，是将String类型的LinkedList传入进去，新建的为root
TreeNode deserialize(LinkedList<String> nodes){
    if(nodes.isEmpty()) return null;
    String first = nodes.removeFirst();
    if(first.equals(NULL)) return null;
    
    TreeNode root = new TreeNode(Integer.parseInt(first));	//不然字符串不能转成Int；
    //	二刷的时候递归写错了
    root.left = deserialize(nodes);
    root.right = deserialize(nodes);
    return root;
    
}
```

<img src="力扣.assets/image-20230604095311759.png" alt="image-20230604095311759" style="zoom:67%;" />

#### 特性篇（二叉搜索树）

##### BST树（二叉搜索树）

二叉搜索树的中序遍历结果是升序

值得注意的是，先左再右的结果是升序的，那么颠倒一下遍历顺序是不是就是降序的？这个一定要注意！！！

##### 538.	把二叉树转化为累加树

​	<img src="力扣.assets/image-20230606224929274.png" alt="image-20230606224929274" style="zoom:80%;" />

```java
//1.	题目的意思，例如节点5，转换后变为 6+7+8 然后在加上5 结果等于26。没问题吧
//2.	头一次刷的时候想到的是既然是二叉搜索树，那么遍历顺序的结果是递增的。右子树的值确实比当前结点值大，可以加上，但是父节点的值呢？父节点的值也比当前节点值大啊？但是没有父节点的指针啊，怎么加呢？
//3.	既然按照先左子树再右子树遍历得到的是升序，那颠倒一下是不是就得到了降序？那这样生命一个临时变量来记录右子树的值最后加到当前节点是不是就满足了？

int sum = 0;

void convert(TreeNode root){
    if(root == null) return;
    convert(root.right);
    sum += root.val;
    //更新节点值
    root.val = sum;
    convert(root.left);
}
```

##### 701.	二叉搜索树中的插入操作

​	<img src="力扣.assets/image-20230610104208541.png" alt="image-20230610104208541" style="zoom:80%;" />

```java
//1.	首先想到的是二叉搜索树中序遍历结果是递增的，但是我再这题上却没有用上。
//2.	用到的方法是将新增节点添加到叶子结点上，那么就一直递归遍历就可以了
//3.	我第一反应想到的是前序遍历，递归节点，但是当root== null时，我还想着通过新造节点TreeNode root = new TreeNode(val),其实可以直接返回return new TreeNode(val) 的，

TreeNode travel(TreeNode root,int val){
    if(root == null) return new TreeNode(val);
    
    if(root.val < val){
        root.right = travel(root.right,val);
    }
    if(root.val > val){
        root.left = travel(root.left,val);
    }
    return root;
}
```

##### 450.	删除二叉搜索树中的节点

​	<img src="力扣.assets/image-20230610162623244.png" alt="image-20230610162623244" style="zoom: 80%;" />

```java
//1.	首先想到的是找到该节点对应的父节点和子节点，然后将父节点指向该节点的子节点，但是怎么找呢？犯得最大的错误就是没有仔细考虑有几种情况。
//2.	那么遍历的时候的返回值是什么？如果函数的返回值是TreeNode，那么递归条件的出口该是什么呢？
//3.	想完之后想法都不对
```

```java
//1.	首先想到的是删除节点，要考虑哪几种情况，其实有三种，
//2.	第一种是如果要删除的节点是叶子节点，那么可以直接删除，如果是该节点只包含一个非空的子节点，那么无论是左孩子还是右孩子，都让该节点代替自己的位置。第三种情况是最麻烦的，如果有两个孩子该怎么办？可以寻找左子树的最大的节点，或者是选择右子树中最小的节点来代替自己的位置。此处选择的是右子树的最小的节点代替自己的位置。

public TreeNode delete(TreeNode root,int val){
    if(root == null) return null;
    if(root.val == val){
        //首先处理前两种情况
        if(root.left == null) return root.right;
        if(root.right == null) return root.left;
        
        //处理两个孩子节点的情况，首先你得获取右子树的最小节点
        TreeNode minRight = getMin(root.right);
        
        //删除右子树的最小节点,为什么要删除呢？因为逻辑是你得找到，然后用它来替换root节点，而且替换之后的root节点不能再含有这个节点了，不然重复
        root.right = deleteNode(root.right,minNode.val);
        //首先你得把root原本的孩子节点都给赋值到minNode上面，然后再将该节点顶替root节点的位置。
        minNode.left = root.left;
        minNode.right = root.right;
        root = minNode;
    }else if(root.val > val){
        root.left = delete(root.left,val);
    }else if(root.val < val){
        root.right = delete(root.right,val);
    }
    return root;
    
    TreeNode getMin(TreeNode node){
        //因为是平衡二叉树，所以最小节点是整个树的最左边的节点，一致往坐下角找就可以
        while(node.left != null) node = node.left;
        return node;
    }
}
```

##### 700.	二叉搜索树中的搜索

```java
//1.	搜索二叉树，判断root值与子树节点值，然后进行递归
//2.	记住返回值，如果树要求有返回值，递归的时候要么声明变量接受一下，要么直接return，切不可直接调用递归方法，例如下面这个
public TreeNode search(TreeNode root,int val){
    if(root == null) return null;
    if(root.val == val) return root;
    
    if(root.val < val){
        //要么声明变量接受，要么return，不可   search(root.left,val);
        return search(root.left,val);
    }else if(root.val > val){
        return search(root.right,val);
    }
    return null;
}

```

##### 96.	不同的二叉搜索树

​	<img src="力扣.assets/image-20230614084114896.png" alt="image-20230614084114896" style="zoom:67%;" />

```java
//1.	真没想到该怎么做？？？？	即便做过两遍了(重点是怎么表示去找不同的左子树和右子树)

//2.	然后想到了二叉搜索树中序遍历是升序的，那么是不是可以找出有多少种升序的遍历顺序来？？？这样也行，但是太麻烦了，这个应该有重叠子问题，应该是属于动规。

//3.	声明dp[i],代表i个节点不同的二叉树的搜索数量
//4.	那对于第i个节点，是不是需要考虑从1.....i之间不同节点作为根节点的数量，然后将其加起来？！！那这样的话是不是得两层循环？j表示从1开始不同的节点对应的搜索树数量

dp[0]=0;
dp[1]=1;

for(int i = 2;i <= n;i++){
    //为什么这里是j<=i呢？不是小于？跟递推公式有关系，等于i的话相减等于0，表示以j为根节点右子树为0的情况
    for(int j = 1;j<=i;j++){
        //记住dp[i] 的含义，一共i个节点，对于根节点j时,左子树的节点个数为j-1，右子树的节点个数为i-j
        dp[i] += dp[j-1]*dp[i-j];
    }
}
return dp[n];

```

#### Git原理之最近公共祖先

​	<img src="力扣.assets/image-20230614215822644.png" alt="image-20230614215822644" style="zoom:67%;" />

```java
//1.	刷这道题的时候脑子很乱，想到既然找公共祖先，那得先确定这两个节点的位置。我先想到了前序遍历但是前序遍历不会给你父节点的信息。所以很明显是后序遍历
//2.	分为了三种情况，如果左右子树不为空，直接return root 就可以。如果左子树为空，返回右子树。如果右子树为空的话，返回左子树。而且记住是遍历整个树。容易想到的是，分布在根节点两边的情况。

if(root == null) return null;
if(root == p || root == q) return root;//	递归的返回条件很重要。

TreeNode left = CommonAncestor(root.left,p,q);
TreeNode right = CommonAncetor(root.right,p,q);

if(left == null && right == null){
    return null;
}else if(left != null && right == null){
    return left;
}else if(left == null && right != null){
    return right;
}else {
    //如果两个都不为空的话，返回他俩的父节点，而且最终肯定都会走到这里的
    return root;
}

```



### 回溯

#### （组合问题：如果结果集中有重复元素，递归条件是i；否则递归条件是i + 1）

**1.电话号码的字母组合**

​		1.首先要定义一个映射的关系。

​		2.不同于普通组合，这是不同集合之间的不同组合

​		3.去看代码

**2.组合求和**（数组中的每一个值在每一个组合中只能使用一次）

​		1.设置boolean类型的used数组来判断之前的是否使用过。

```java
//for循环中的条件
if(i > 0 && nums[i] == nums[i-1] && !used[i])
```

#### 分割问题

**1.分割回文串**

​		1.多了一个判断是否为回文串的过程，不是的话就continue；

**2.ip地址问题**

​		1.设置pointSum，如果  . 的数量等于三，之后在判断最后那一段字符串是否符合要求，符合就加入进去

```java
if(pointSum == 3){
    if(isLegal(s,startIndex,s,length() - 1)){
        result.add(s);
    }
}
```

​		2.逗点的加入；也就是字符串的加入

```java
//字符串是能动态处理，只能截取之后拼接，StringBuilder对象类型的字符串可以动态处理
s = s.substring(0,i + 1) + "." + s.substring(i+1);
```

​		3.求和问题给定字符串的起始节点跟终止节点

```java
int sum = 0;
for(int i = left;i < right;i++){
    sum = sum * 10 +(s.charAt(i) - '0');
}
```

​		4.从字符串charAt出来的数字需要 - '0'才是正常的数字

```java
s = "123456"
System.out.println( (s.charAt(0) - '0') * 10)
    //这样才能输出10
```

#### 子集问题

**1.子集1和子集2**

​		1.子集1不包含重复元素，返回可能的所有子集，解集中不能包含重复元素。

​		2.子集2包含重复元素，返回所有的可能的子集，解集中不能包含重复元素。

```java
对比子集1，子集2的处理方式是首先对数组排序，然后使用used数组。
```

**2.递增子序列**

#### 排列问题（都用不到startIndex）

**1.全排列**

1.不用startIndex来控制不取之前的元素，通过used数组来控制当前元素取过就不再取了。

```java
//注意两个点。一个是没有startIndex，i从0开始的
//另外一个是used数组，标记了就不能再取当前元素了。
for(int i = 0;i < nums.length;i++){
	if(sued[i]){
        continue;
    }
    used[i] = true;
    path.add(nums[i]);
    backtracking(.....);
}
```

### 贪心算法

#### 一般两个变量，一个动态记录最大值，一个用来运算。

**1.分发糖果**

​		1.一个循环条件中控制两个变量

```java
for(int i = 0;i < s.length && start < g.length;i++){
    if(s[i] >= g[start]){
        count++;
        start++;
    }
}
```

**2.摆动序列**

​		1.处理边界序列，所以默认就有一个；即count = 1；

​		2.

```java
if((curDiff > 0 && preDiff <= 0) || (curDiff < 0 && preDiff >=0)){
    count++;
}
```

**3.最大子数组和**

​	1.设置count用于动态的选取初始位置

​	2.如果count <= 0,说明加了一个负数，重置count = 0；（可以加小一点的负数，但是最大值记录的是在没加这个很小的负数的时候的		值）

**4.买卖股票的最佳时机**

​		1.所以只需要将买卖股票的时间转换成每天买卖的利润即可

```java
prices[3] - prices[1] = (prices[3] - prices[2]) + (prices[2] - prices[1])
```

​		2.只记录利润为正的和

**5.跳跃游戏**

​		1.确保覆盖范围能够大于数组的长度即可，在第一个位置的时候 >= nums.length - 1 即可

​		2.不断的更新覆盖范围

```java
for(int i = 0; i< coverRange;i++){
    coverRange = Math.max(coverRange,i + nums[i]);//i + nums[i]的i表示之前已经跳过的步子；
}
```

**6.跳跃游戏II**

​		1.每次在上次能跳到的范围（end）内选择一个能跳的最远的位置（也就是能跳到max_far位置的点）作为下次的起跳点 。

```java
int end = 0;//作为能够跳跃达到的右边界；
int maxPosition = 0;//最为能够跳到的最远的位置
int step;
for(int i = 0;i < nums.length - 1;i++){
    maxPosition = Math.max(maxPosition,i + nums[i]);//找覆盖到的跳跃范围内的最大值；
    if(i == end){//i 走到了i下标对应的覆盖最远位置后；
		end = maxPostion;
        step++;
    }
}
```

**7.加油站**

​	1.计算出总的耗油量，如果是负数，无论如何都不可能走完全称；

​	2.计算每一段路程最小的耗油量

```java
minGas = Math.min(sumGas,minGas)
```

​	如果说最小的耗油量都大于0的话，那么for循环从i = 0开始的，即0号加油站就符合要求

​	3.如果不是的话，那么倒叙循环，不断的计算每一个加油站与最小油耗的和，当把最小油耗变成>=0的时候，遍历到的i就是起始位置。

**8.根据身高重建队列**

**9.射爆气球**

**Arrays.sort重写**

```java
[[1,2],[3,4],[3,5]]
Arrays.sort(person,(a,b) ->{
    return a[0] - b[0];
})
// a - b 表示升序；
// b - a 表示降序；
```

**10.无重叠区间**

​		1.从左到右去遍历，首先按照[a,b]中的b对集合进行从小到大的排序

​		2.初始化右边界为最小值，处理集合中第一个区间

​		3.若上一个区间的右边界小于当前区间的左边界说明没有重叠部分；更新边界

```java
edge = nums[i][1]
```

```java
else{
    count++;
}
```

**11.划分字母区间**

​		1.确定每一个元素出现的最远位置。

​		2.重新遍历字符串，不断更迭出现的最远距离，如果最远距离刚好与遍历的下标i相等。此时做分割。

**12.单调递增的数字**

​		1.需要start确定从哪个位置开始赋值9；

​		2.包括将数字转化成字符串等。

**13.买卖股票的最佳时机含手续费**

### 动态规划

#### 动归五部曲-基础

```java
//	1.确定dp数组下标及其含义
//	2.确定递推公式
//	3.dp数组如何初始化
//	4.确定遍历顺序
```

#### 什么时候用动态规划？

```java
//1.	一般具有最优子结构，能够从局部最优推出全局最优
//2.	一般最值题，用到的就是动态规划
```

#### 数组的初始化

```java
//1.	为什么有的要初始话成dp[n+1]或者dp[n+1][m+1]而不是dp[n][m]呢？
//2.	一般来说，如果递推公式中要用到 i-1 等类似的判断，就要用到偏移量，因为索引不能为-1。 当然这种情况也不是绝对的，大部分来说是的，具体还要具体情况具体分析
```

#### dp数组的遍历方式

```java
//1.	正向遍历
int[][] dp = new int[m][n];
for (int i = 0; i < m; i++){
    for (int j = 0; j < n; j++)
        // 计算 dp[i][j]
}
        
//2.	反向遍历
for (int i = m - 1; i >= 0; i--){
    for (int j = n - 1; j >= 0; j--)
        // 计算 dp[i][j]
}


//3.	斜着遍历
for (int l = 2; l <= n; l++) {
    for (int i = 0; i <= n - l; i++) {
        int j = l + i - 1;
        // 计算 dp[i][j]
    }
}
  
```



##### **1.最小花费爬楼梯**

​		1.dp数组的长度是length + 1，+1代表走到楼顶。

##### **2.整数拆分**

​		1.拆成相似的数的时候乘积最大（数学证明）

##### **3.不同的二插搜索树**

​		1.给定一个数字n，确定搜索树个数

​		2.dp[i] 对应的是i个节点的搜索树个数有多少

​		3.以j为头结点，遍历i

```java
dp[0] = 1,dp[1] = 1;
for(int i = 2;i <= n;i++){
    //j代表从1-i个数中选取的不同的数当头结点，=的时候表示右子树是空的情况
    for(int j = 1;j <= i;j++){
        //j-1因为搜索树左子树都比头结点小，i-j代表右子树，因为右子树节点值都比头结点大
        dp[i] += dp[j-1]*dp[i-j];
    }
}
```

#### 	背包问题

![image-20221209210258910](力扣.assets/image-20221209210258910.png)

##### 139.	单词拆分

​	<img src="力扣.assets/image-20230609091828323.png" alt="image-20230609091828323" style="zoom:80%;" />

```java
//1.	第一眼看过去肯定会包含字符串的截取，因为思路就是，判断截取的字符串是否存在于这个列表里面，既然可以无限制的选取，可以用Set来存储列表中的集合。
//2.	既然是截取字符串，那么肯定是两层遍历，那么递推公式是什么呢？ if(set.contains(s.substring(j,i) && dp[j]) dp[i] = true
//3.	第一次做递推公式的时候，忘记了 && dp[j] 
//4.	dp数组的初始化，dp[0]一定得是true，不然没法递推
//5.	为什么dp数组要初始化成s.length()+1,因为你想想啊，截取的substring，前面那一位是不取的，要是只是字符串的长度的话，最后一个字符永远的截取不到啊。
//		例如，s.substring(0,3),第三个字符是截取不到的，如果3刚好是字符串的长度的话，那么就永远截取不到最后一个字符，无法判断。所以要s.length()+1

boolean[] dp = new boolean[s.length()+1];
for(int i = 1;i <= s.length();i++){
    for(int j = 0;j < i;j++){
        if(set.contains(s.substring(j,i)) && dp[j]){
            dp[i] = true;
        }
    }
}
return dp[s.length()]

```

**1.0-1背包就是有n中物品，每种物品只有一个**

**2.完全背包是有n中物品，每种物品有无数个**

**3.多重背包是有n种物品，每种物品个数各不相同**

```java
//初始化问题
//递推公式及遍历顺序
for(int i = 1;i <= weight.length;i++){
    for(int j = 1;j <= bagSize;j++){
        if(j < weight[i-1]){
            dp[i][j] = dp[i-1][j];
        }else{
            dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-weight[i-1] + value[i]]);
        }
    }
}
```

**1.最后一块石头的重量**

​		1.将石头总和分成两堆，其中一堆作为背包，石头的重量跟价值都是数组中元素，求dp[j]

```java
//最终结果
result = sum - dp[target] - [target]
```

**2.目标和**

​		1.给定nums[]和target；

​		2.数组里肯定有两部分left - right = target；还有一部分是固定的 left+right = sum；整理得到left = （sum + target) / 2;

​			所以题意可以理解为，给定一个left背包，有多少种组合方式能将该背包装满。

​		3.装满背包方式的递推公式为 dp[j] = dp[j-nums[i]]；所以总的方式有dp[j] += dp[j-nums[i]]; 

**1和0**

#### 完全背包问题

```java
//与0-1背包的区别
0-1：
for(int i = 0;i < weight.length;i++){
    for(int j = bagSize;j >= weight[i];j--){
        dp[j] = Math.max(dp[j],dp[j-weight[i]] + value[i]);
    }
}
//完全背包
for(int i = 0;i < weight.length;i++){
    for(int j = weight[i];j <= bagSize;j++){
        dp[i] = Math.max(dp[j],dp[j-weight[i]] + value[i]);
    }
}
//应用方面求背包最大价值
dp[j] = Math.max(dp[j],dp[j-weight[i]] + value[i]);
//应用方面求装满背包有多少中方法
dp[j] += dp[j-weight[i]];

```

#### 买卖股票问题：

**1.买卖股票的最佳时机(只允许一次交易）**

​		1.股票问题初始化dp数组为二维状态（持有股票、不持有股票）

```java
int[][] dp = new int[len][2];
//持有股票:dp[i-1][0]是指前一天也可能持有，今天没买入而已，另外一种情况是前一天没有，当天买入，花掉了prices[i]
dp[i][0] = Math.max(dp[i-1][0],-prices[i]);
//不持有股票:
dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0] + prices[i]);
```

**2.买卖股票的最佳时机（允许多次交易）**

​		1.与上面唯一的不同点是

```java
//持有股票
dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1] - prices[i]);
```

**3.买卖股票的最佳时机（至多允许两次交易）**

**4.买卖股票的最佳时机IV**

**5.买卖股票的最佳时机含冷冻期**

**6.买卖股票的最佳时机含手续费**

```java
//初始化
dp[0][0] = -prices[i]
//递推公式
dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1] - prices[i]);
dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0] + prices - fee);
```



#### 子序列问题

##### 300	最长递增子序列

​	<img src="力扣.assets/image-20230604212350344.png" alt="image-20230604212350344" style="zoom: 80%;" />

```java
//1.	dp[i] 代表 以当前位置结尾的最长子序列长度
//2.	转移方程是什么？？		位置i的最长递增子序列为0到i-1的最长上升子序列 + 1；
//3.	那怎么去找0 到 i-1 的最长上升子序列呢？？	再遍历一遍。
//4.	最终的结果是啥呢？	dp[num.length]？ 绝对不是，dp[i]代表的含义是以nums[i]为结尾的最长子序列长度，所以我们的结果是找dp数组中的最大值。

for(int i = 0;i < nums.length;i++){
    for(int j = 0;j < i;j++){
        if(nums[i] > nums[j]){
            //dp[i] 是第二遍遍历的时候不断地变化的，一直变到最大值
            dp[i] = Math.max(dp[i],dp[j] + 1);
        }
    }
}
//遍历找到最大值


int res = 0;
for(int i = 0;i < dp.length;i++){
    res = res > dp[i]?res:dp[i];
}
return res;
```

##### 115.	不同的子序列

​	<img src="力扣.assets/image-20230606103945903.png" alt="image-20230606103945903" style="zoom: 80%;" />

​	![image-20230606110641287](力扣.assets/image-20230606110641287-1686026702361-1.png)

​	第二种理解

​	<img src="力扣.assets/image-20230606125244372.png" alt="image-20230606125244372" style="zoom:67%;" />

```java

//1.	刚开始想的是背包问题，不明白的是怎么取？用什么方式装满，因为字符串不能加减。所以这明显不是背包问题，背包问题适合数字。
//2.	既然不是背包问题，那就是定义dp[][],dp[i][j]的含义是什么？
//3.	dp[i][j]代表前i个字符串可以由j个字符串组成的个数。
//4.	动态转移方程是什么？如果遍历s.charAt(i-1) != t.charAt(j-1) 那最多的次数是dp[i-1][j],即i之前能包含多少次，这里也只能包含多少次
//		那如果相等的话是什么情况？ 分为 i 这个字符串可以取也可以不取，dp[i-1][j-1] + dp[i-1][j]，那如果取的话就是跟之前i-1，j-1结尾的字符串的子序列个数一致，注意是个数。那如果不取的话，就跟i-1，j结尾的子序列个数一致。为什么相等的时候有取或者不取这两种情况呢？就好像我们逛街一样，我们遇到了自己的目标店铺的时候会有两种选择，一种是就它了进去买买买，另一种选择是再往前走走，说不定前面还有 但是如果我们始终没有遇到想看的店铺的时候，就必须往前走，只有这一种选择。

题解链接：https://leetcode.cn/problems/distinct-subsequences/solution/115-bu-tong-de-zi-xu-lie-by-shen-du-rm-18kr/


for(int i = 1;i <= m;i++){
    for(int j = 1;i <= n;j++){
        if(s.charAt(i-1) == t.charAt(j-1)){
            dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
        }else{
            dp[i][j] = dp[i-1][j];
        }
    }
}
```

其实上面的解法就是0-1背包问题，没有用滚动数组，就是取第i个字符跟不取第i个字符的情况，s为物品，t为背包。下面这个是用了滚动数组做优化

```java
//方法2：
//1.	前面说不能背包问题，打脸了，其实是可以背包问题的，只是编码能力弱，不懂融会贯通
```

​	<img src="力扣.assets/image-20230606123417254-1686026709928-3.png" alt="image-20230606123417254"  />

##### 1143.	最长公共子序列

​	<img src="力扣.assets/image-20230613090919682.png" alt="image-20230613090919682" style="zoom:67%;" />

```java
//1.	最长公共子序列，我的第一反应是跟编辑距离那一道题差不多，都是二维dp数组遍历，唯一不同的是如果两个字符不相等的话是什么情况？
//2.	公共子序列，如果不想等的话，就找dp[i-1][j],dp[i][j-1]两者的最小值就可以了。（i少一个字符，或者j少一个字符）

for(int i = 1;i <= m;i++){
    for(int j = 1;j<= n;j++){
        if(s1.charAt(i-1) == s2.charAt(j-1)){
            dp[i][j] = dp[i-1][j-1] + 1;
        }else{
            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
        }
    }
}
return dp[m][n];
```



##### **2.最长重复子数组、最长公共子序列(不相交的线）**

​		1.最长重复子数组，数组元素之间必须相连，找到最长的公共部分，如：[1,2,3,2,1]和[3,2,1,4,7]公共部分 **[3,2,1]**

​		2.最长公共子序列，元素之间可以不必相连，找出最长的公共部分，如："a,b,c,d,e"和"a,c,e"公共部分 **a,c,e**

```java
//1.递推公式
if(nums[i-1] == nums[j-1]){
    dp[i][j] = dp[i-1][j-1] + 1;
}
//2.递推公式
if(ch[i-1] == ch[j-1]){
    dp[i][j] = dp[i-1][j-1] + 1;
}
else{
    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
}
```

##### **3.判断子序列**

​		1.跟求最长公共子序列套路一样，但是在s[i-1] != t[j-1]的时候，因为t字符串的长度是大于s的，所以t要删除当前的t[i-1]

```java
如果删除t[t-1],则dp[i][j] 就要由dp[i-1] 和 dp[j-2]决定。即dp[i][j] = d[i][j-1]
if(s[i-1] == t[i-1]){
    dp[i][j] = dp[i-1][j-1] + 1;
}else{
    dp[i][j] = dp[i][j-1];
}
//最后遍历dp数组找出最长子序列的值看看是否与s.length()相等；
```

##### **4.不同的子序列**

##### **5.两个字符串的删除操作**

##### **6.字符串中有多少个回文子串**

```java
for(int i = len -1;i >= 0;i--){
    for(int j = i;j < len;j++){
        if(str[i] == str[j]){
            if(j -i >= 1){
                dp[i][j] = true;
                count++;
            }else if(dp[i+1][j-1]{
             	dp[i][j] = true;
                count++;
            }
        }
    }
}
```



#### 7.编辑距离

​	<img src="力扣.assets/image-20230604214626470.png" alt="image-20230604214626470" style="zoom:80%;" />

```java
//1.	左上角三个值分别对应什么操作？  [i-1][j-1]:替换，[i-1][j] 删除 [i][j-1] 增加

//2.	dp[i][j] 含义？ 以下表[i-1]结尾的字符串s1,和以下表[j-1]为结尾的字符串，最近编辑距离为dp[i-1][j-1]
//		这就要求我们从1开始遍历，

//3.	dp初始化为多少？dp[0][j] = j; 空字符串变成j个字符的字符串需要添加j次操作，同理dp[i][0] = i，需要进行i次增加操作
//		一定要注意初始化，不是dp[0][j] =1;dp[i][0] = 1

//4.	递推公式
for(int i = 1;i <= m;i++){
    for(int j = 1;j <= n;j++){
        if(s1.charAt(i-1) == s2.charAt(j-1)){
            dp[i][j] = dp[i-1][j-1];
        }else{
            dp[i][j] = Math.min(Math.min(dp[i-1][j],dp[i][j-1]),dp[i-1][j-1]) + 1;
        }
    }
}
return dp[m][n];
```

#### 子数组问题root

##### 53.	最大子数组和

​	<img src="力扣.assets/image-20230612094737654.png" alt="image-20230612094737654" style="zoom:67%;" />

```java
//1.	第一眼望过去，想到了滑动窗口，但是要处理的东西条件太多了，仔细看一眼，求最值问题，可以由局部推出整体，可以选择动规来搞
//2.	dp[i]的含义是什么，代表以i为结尾的子数组的最大值。
//3.	递推公式是什么？dp[i] = Math.max(nums[i],dp[i-1] + nums[i]),  含义是什么，子数组啊！！必须是连接状态的，反正不能加上值之后变小。  dp[i] 有两种「选择」，要么与前面的相邻子数组连接，形成一个和更大的子数组；要么不与前面的子数组连接，自成一派，自己作为一个子数组。
//4.	然后最终返回的是什么？   肯定是遍历dp数组，找到dp数组中的最大值啊！（仔细考虑）

for(int i = 1;i < nums.length;i++){
    dp[i] = Math.max(dp[i-1] + nums[i],nums[i]);
}
for(int i = 0;i < dp.length;i++){
    result = Math.max(dp[i],result);
}
```

#### 动态规划玩游戏

##### 64.	最小路径和

​	<img src="力扣.assets/image-20230615092312283.png" alt="image-20230615092312283" style="zoom:67%;" />

```java
//1.	没注意审题，最小路径和，只能向下或者向右移动一步。刚开始的时候没有审好题。
//2.	初始化dp数组为什么样？dp[m+1][n+1]吗？其实完全不需要，因为你求的是和，并且for循环中并没有条件判断。二维数组中的每一个值都代表了到达当前位置所需要的最小的路径和。那就要初始化第一行和第一列。而且并不需要m+1和n+1；我在这里没想过来，犯了糊涂。
//3.	dp[0][0] = grid[0][0];
for(int i = 1;i < m;i++){
    dp[i][0] = dp[i-1][0] + grid[i][0];
}
for(int j = 1;j < n;j++){
    dp[0][j] = dp[0][j-1] + grid[0][j];
}

for(int i = 1;i < m;i++){
    for(int j = 1;j < n;j++){
        dp[i][j] = Math.min(dp[i-1][j],dp[i][j-1]) + grid[i][j];
    }
}
return dp[m-1][n-1];
```

##### 174.	地下城游戏

​	<img src="力扣.assets/image-20230618100708271.png" alt="image-20230618100708271" style="zoom:80%;" />

```java
//1.	刚开始的第一个想法是，从前往后遍历，但是这样的话递推公式是不能确定的，他求的是至少需要多少血量，从前往后的话，你求累加是不行的，确实能够保证是最大血量活着的，但是不能保证“至少”这个字眼。
//2.	从后往前遍历
//3.	注意一个重要条件，如果活着，那每个格子不能是负数，负数的话就已经寄了。所以最少每个格子都是0；明白这一点很重要。那就必须要初始化最后一行和最后一列
//4.	dp[i][j] 代表的是需要最少血量！！需要！！
dp[0][0] = Math.max(0，-num[m-1][n-1]);

//设置最后一列的值
for(int i = m-2;i >=0;i--){
    int needMin = dp[i+1][n-1] - dungeon[i][n-1];//表示前一个格子需要的血量 - 当前个消耗的血量
    dp[i][n-1] = Math.max(0,needMin);
}
//设置最后一行的值
for(int j = n-2;j >= 0;j--){
    int needMin = dp[m-1][j+1] - dungeon[m-1][j];//表示前一个格子需要的血量 - 当前个消耗的血量
    dp[m-1][j] = Math.max(needMin,0);
}

for(int i = m-2;i >=0;i--){
    for(int j = n-2;j >= 0;j--){
        int needMin = Math.min(dp[i+1][j],dp[i][j+1]) - dungeon[i][j];
        dp[i][j] = Math.max(0,needMin);
    }
}

return dp[0][0]+1	//加1的目的是保证是活着的。
```

##### 10.	正则表达式匹配

​	<img src="力扣.assets/image-20230621095446185.png" alt="image-20230621095446185" style="zoom:67%;" />

```java
//1.	第一反应无从下手
//2.	true还是false，其实是用动态规划来做的。就是字符的匹配问题。答案链接：

https://leetcode.cn/problems/regular-expression-matching/solutions/296114/shou-hui-tu-jie-wo-tai-nan-liao-by-hyj8/

public boolean isMatch(String s, String p) {
    int sLen = s.length();
    int pLen = p.length();

    boolean[][] dp = new boolean[sLen+1][pLen+1];

    dp[0][0] = true;
    //a是空串，p不是
    //为什么从2开始，因为题目给出的要求是，每次出现字符*时，前面都匹配到有效的字符
    for(int j = 2;j <= pLen;j++){
        if(p.charAt(j-1) == '*'){
            dp[0][j] = dp[0][j-2];
        }
    }
    //注意二维矩阵i-1代表着删除i
    for(int i = 1;i <= sLen;i++){
        for(int j = 1;j <= pLen;j++){
            //如果匹配上，或者有 . 
            if(s.charAt(i-1) == p.charAt(j-1) || p.charAt(j-1) == '.'){
                dp[i][j] = dp[i-1][j-1];
                //如果匹配不上，但是p的最后一个是*
            }else if(p.charAt(j-1) == '*'){
                if(s.charAt(i-1) == p.charAt(j-2) || p.charAt(j-2) == '.'){
                    //分别代表这个* 是重复0次，还是1次，还是>= 2次
                    dp[i][j] = dp[i-1][j] || dp[i-1][j-2] || dp[i][j-2];
                    //如果最后一个是*，但是i-1和j-2匹配不上，不要紧，把i-1这个字符干掉，然后p继续往前走。
                }else{
                    dp[i][j] = dp[i][j-2];
                }
            }
            //其余的情况都是false，声明的二维数组默认就是false
        }
    }
    return dp[sLen][pLen];
}
```

##### 887.	鸡蛋掉落

​	![image-20230623101539216](力扣.assets/image-20230623101539216.png)

```java
//	https://leetcode.cn/problems/super-egg-drop/solutions/44427/ji-ben-dong-tai-gui-hua-jie-fa-by-labuladong/
//	有点难，抽空理解吧
```

##### 42.	接雨水

​	<img src="力扣.assets/image-20230710093831500.png" alt="image-20230710093831500" style="zoom:80%;" />

```java
//1.	其实这道题想到解题方程就很容易做出来
//2.	当前i位置所能盛的最多的水是多少？通过关系来说是height[i-1],跟height[i+1]之间的最小值，然后减去height[i]；
//3.	那可以用暴力的方式，去搜寻当前位置i的左边的最高的，跟右边的最高的。时间复杂度肯定是O(N)但是能通过

//4.	暴力解法
int res = 0;
for(int i = 0;i < height.length;i++){
    int lmax = 0,rmax = 0;
    for(int j = i;j < height.length;j++){
        rmax = rmax >= height[j]?rmax:height[j];
    }
    for(int j = i;j >=0;j--){
        lmax = lmax >= height[j]?lmax:height[j];
    }
    res += Math.min(lmax.rmax) - height[i];
}
return res;

//5.	动态规划、既然每一次都要遍历搜索，那就包含了子问题；可以声明两个数组，用来记录左边的最高，跟右边的最高；左边的最高等于lmax[i-1],height[i-1]的最大值

int res = 0;
int[] lmax = new int[height.length];
int[] rmax = new int[height.length];
for(int i = 1;i < height.length;i++){
    lmax[i] = Math.max(lmax[i-1],height[i-1]);
}
//找右边的最大值，相当于从右边开始遍历。
for(int i = height-2;i >= 0;i--){
    rmax[i] = Math.max(rmax[i+1],height[i+1]);
}

for(int i = 0;i < height.length;i++){
    int temp = Math.min(lmax.rmax);
    if(temp > height[i]){
        res += temp - height[i];
    }
}
return res;
```



### 各种数据结构

#### 496.	下一个更大的元素

​	<img src="力扣.assets/image-20230707100848787.png" alt="image-20230707100848787" style="zoom:80%;" />

```java
//	单调栈的解法，也可以两层for循环
//	单调栈用于解决下一个更大的元素或者下一个更小的元素
//	单调栈模板
int[] nextElemnt(int[] nums){
	int n = nums.length;
    int res = new int[n];    
    
    Stack<Integer> s = new Stack();
    //按照栈的特性，倒着往里放其实就是正着出
    for(int i = n -1;i >= 0;i--){
        while(!s.isEmpty() && s.peek() < nums[i]){
            //小的都起开，只留下大的
            s.pop();
        }
        
        res[i] = s.isEmpty()?-1:s.peek();
        s.push(nums[i]);
    }
}
```

#### 146.	LRU缓存

```java
//	参考收集内存，有两个问题首先是如何快速定位一个元素，然后是能够快速支持随机插入
//	针对两种问题，设计一个双向链表哈希的数据结构
//	实现步骤是什么？1.	定义一个双向链表内部类	2.	定义一个哈希表	3.	实现构造函数	4.实现LRU的两个接口即get和put	5.传入的参数是capacity（容量）

class LRUCache{
    //	1.定义一个双向链表
    class DLinkedNode{
        int key,val;
        DlinkedNode pre,next;
        public DlinkedNode(){};
        public DlinkedNode(int key,int val){
            this.key = key;
            this.val = val;
        }
    }
    //	2.定义哈希
    private HashMap<Integer,DLinkedNode> cache = new HashMap();
    //	3.定义参数，实现构造函数
    private int size;	//记录当前容量
    private int capacity;
    private DLinkedNode head,tail;
    
    public LRUCache(int capacity){
        this.capacity = capacity;
        this.size = 0;
        //	内部类可以使用外部类的所有资源
        head = new DLinkedNode();
        tail = new DLinkedNode();
        
        head.next = tail;
        tail.pre = head;
    }
    
    //	4.实现两个接口，分别是get和put
    public int get(int key,int value){
        DLinkedNode node = cache.get(key);
        if(node == null){
            return -1;
        }
        //如果存在的话，移动到链头位置,怎么moveToHead呢？先删除该节点，然后将它添加到链头；
        moveToHead(node);
        return node.val;
    }
    
    public void put(int key,int value){
        DLinkedNode node = cache.get(key);
        if(node == null){
            DLinkedNode newNode = new DLinkedNode(key,val);
            //添加进map
            cache.put(key,newNode);
            addToHead(newNode);
            size++;
            if(size > capacity){
                //删除尾节点
                DLinkedNode tail = removeTail();
                //从map中删除tail
                cache.remove(tail.key);	//	tail是一个链表节点，里面的key跟HashMap中的key是一样的。
                size--;
            }
        }else{
            node.val = value;
            moveToHead(node);
        }
    }
    public void moveToHead(DLinkedNode node){
        removeNode(node);
        addToHead(node);
    }
    public void removeNode(DLinkedNode node){
        node.pre.next = node.next;
        node.next.pre = node.pre;
    }
    
    public void addToHead(DLinkedNode node){
        node.pre = head;
        node.next = head.next;
        head.next.pre = node;
        head.next = node;
    }
    public DLinkedNode removeTail(){
        DLinkedNode res = tail.pre;	//tail是虚拟节点，构造参数时声明过全局的，所以有tail的前一个也就是最后一个节点的指针
        removeNode(res);
        return res;
    }
    
}
```

### 算法技巧

#### 200.	岛屿数量

​	<img src="力扣.assets/image-20230712200236395.png" alt="image-20230712200236395" style="zoom:80%;" />

```java
//1.	首先是DFS算法，跟二叉树类似
//2.	你得保证走过的就不要再走了，那怎么保证走过的就不要走了呢？一个是维护一个visited数组，另外一个就是走过的岛屿=='0'，这样就可以保证不用回头
int m = nums.length,n = nums[0].length;

for(int i = 0;i < m;i++){
    for(int j = 0;j < n;j++){
        if(nums[i][j] == '1'){
            res++;
            //开始dfs遍历
            dfs(nums,i,j);
        }
    }
}
return res;

void dfs(char[][] nums.int i,int j){
    int m = nums.length,n = nums[0].length;
    
    if(i < 0 || j < 0 || i >= m || j >= n){
        return;
    }
    if(nums[i][j] == '0'){
        return;
    }
    //走过的海域就用0覆盖掉，
    nums[i][j] = '0';
    dfs(nums,i-1,j);
    dfs(nums,i+1,j);
    dfs(nums,i,j-1);
    dfs(nums,i,j+1);
    
}

```

#### 剑指offer105.	岛屿的最大面积

​	<img src="力扣.assets/image-20230712203950596.png" alt="image-20230712203950596" style="zoom:80%;" />

```java
//1.	刚开始做这道题目的时候，想着是确实是要定义一个int类型的dfs函数，但是在外面声明一个temp变量在dfs里面进行++是不对的。这个就跟统计二叉树节点个数一样，你得返回dfs相加才行。
int res = 0;
for(int i = 0;i < m;i++){
    for(int j = 0;j < n;j++){
        if(nums[i][j] == 1){
            res = Math.max(res,dfs(nums,i,j));
        }
    }
}
return res;

int dfs(int[][] nums,int i,int j){
    if(i < 0 || j < 0 || i >= m || j >= n){
        return 0;
    }
    if(nums[i][j] == 0){
        return 0;
    }
    //将岛屿变成陆地，不用回头。
    nums[i][j] = 0;
    
    return dfs(nums,i-1,j) + dfs(nums,i+1,j) + dfs(nums,i,j-1) + dfs(nums,i,j+1);
}
```

##### 1365.	有多少小于当前的数字

​	<img src="力扣.assets/image-20230728092337871.png" alt="image-20230728092337871" style="zoom:80%;" />

```java
//1.	直接暴力解法
for(int i = 0;i < num.length;i++){
    int count = 0;
    for(int j = 0;j < num.length;j++){
        if()...
    }
}
```

##### 941.	有效的山脉数组

​	<img src="力扣.assets/image-20230728095521136.png" alt="image-20230728095521136" style="zoom:80%;" />

```java
//1.	双指针的思路，判断出现转折的时候两个指针是否相同，相同就是true。
while(left+1<nums.length && nums[left] < nums[left+1]){
    left++;
}
while(right...);

if(left == right && left != 0 && right != nums.length-1){
    return true;
}
```

