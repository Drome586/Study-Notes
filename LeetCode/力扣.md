# 力扣疑难点

## 代码随想录

### 数组

**数组，List，Map，Set之间的相互转换**

```java
int[] re = ...
List<> res = 
//转换成List
    Arrays.asList(re);//不能修改结构只能查找
	new ArrayList<>(Arrays.asList)//这种的都可以
        
//List转换成数组
    res.toArray()//不推荐，转换成Object类型
    res.toArray(new int[])// 推荐
//List --> set
        addAll
        目的去重
//set --> List
        addAll
        目的排序
```

### Map

```java
//添加操作
map.put(key,value);
//删除操作
map.remove(key);

//查询操作
map.containsKey(key);
map.get(key);

//修改  key1替换为key2
map.replace(key1,key2);

//遍历所有的key
Set set = map.keySet()
for(Object obj:set){
}

//遍历所有的value
map.values();

//遍历键值对
map.entrySet();

//初始化键值对
Map<Character,Integer> map = new HashMap<>(){
    {
        put('a',1);
        put('b',2);
    }
}

//Map.getOrDefault(key,默认值)

Map中会存储一一对应的key和value。
如果 在Map中存在key，则返回key所对应的的value。
如果 在Map中不存在key，则返回默认值。
    
//返回键值对的数量,也可以判断map是否为空
    
map.size()

//从0开始的for循环，map添加出现元素的次数
for(int i = 0;i < nums.length;i++){
    map.put(nums[i],map.getOrDefault(nums[i],0) + 1);
}
```

### 堆跟优先队列

```java
//堆		完全二叉树   按照层序遍历的方式用一维数组表示
//在一维数组中，父节点为i  左节点2i+1	  右节点2i+2


//新建一个优先级队列，小根堆；将键值对加入到优先级队列中；
//存储的是一个数组，里面放(key,value)
//(pair1,pair2)->pair1[1]-pair2[1] 定义的比较器；默认是升序排列的；下面的有比较器的举例；
PriorityQueue<int[]> que = new PriorityQueue<>((pair1,pair2)->pair1[1]-pair2[1]); //加入的是键值对；
PriorityQueue<int[]> que = new PriorityQueue<>((pair1,pair2)->pair2[1]-pair1[1]); //按照降序排列

返回前k个高频元素
PriorityQueue<int[]> que = new PriorityQueue<>((pair1,pair2)->pair2[1]-pair1[1]);
//遍历map
for(map.Entry(Integer,Integer) entry:map.entrySet()){
    que.add(new int[]{entry.getKey,entry.getValue});
}
int[] ans = new int[k];
for(int i = 0;i < k;i++){
    ans[i] = que.poll()[0];
}
return ans;
```

#### KMP算法

```java
主要是求next数组
//例如	“google”
```

#### String与Int转换

```java
//字符串转数字；包装类parseXXX()
String str = "456";
int a = Integer.parseInt(str)   456
int b = Integer.parseDouble(str)  456.0
    
int c = str.charAt(0) - '0'   4
    
//数字转为字符串
Integer a1 = 123;
int a2 = 456;

//首选既可以用于包装类又可以用于基本数据类型
String str = String.valueOf(a1);

String str = a1 + "";

//toString()只能用于包装类
String  srt = a1.toString(); "123"

```



**1.移除元素**：

​		快慢指针。条件不等于val，用快指针覆盖慢指针。

**2.长度最小的子数组**：

```java
//滑动窗口模板
for(){
    while(){
        .....
    }
}
```

​		1.一个for循环嵌套一个while，自增加和，while条件是大于target之后，开始移动窗口

​		2.不需要排序。

**3.螺旋矩阵**：（给定一个数n，返回n*n矩阵）

​		1.while循环体中是loop++ < n / 2；for循环中的终止条件是j < n -loop;

### 链表

**1.移除链表元素**：

​		1.首先设置头指针

​		2.设置pre跟cur，永远记住pre跟cur只是两个指针。

**2.设计链表**：

​		1.查找指定index的元素时，通过：

```java
for(int i = 0;i <= index;i++){
    cur = cur.next;
}
```

​		2.并且涉及到查找等，都要设置 ListNode cur = head;

​		3.双向链表的添加：先1,3再2,4。先确定好添加节点的前后指针。

<img src="力扣.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54qA54mb6LaF5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img" style="zoom: 67%;" />

****

**3.反转链表**

​		1.涉及到交换元素，必须要设置一个临时变量temp=null；

​		2.将设置一个空链表pre=null，然后将head链表取出头一个节点加入pre，最后返回pre。

**4.两两交换链表中的元素**：

​		1.主要找到最后两个元素，然后进行递归交换

```java
(条件)
ListNode next = head.next;
ListNode temp = swap(next.next);
```

**5.删除倒数第n个节点的值**

​		1.设置快慢指针，利用快慢之间的差等于n来判断，当快指针走到链表结束的时候，慢指针所在的位置就是要删除的倒数第n个节点

​		2.设置头结点。

**6.链表相交**	

​		1.短的链表一直走，走到头再去走长的，长的再走，走到头在走短的，这样两者有共同节点必定会相遇，没有共同节点的话也必定会			同时指向null

```java
//赋值语句，先是pA == null ? headB:pA.next，之后才是赋值给pA。
pA = pA == null ? headB:pA.next;
```

### 哈希表

**1.快乐数**

​		1.设置一个HashSet集合，防止计算之后还是n陷入死循环。

​		2.声明一个计算的方法。

**2.四数之和**：

​		1.用一个Map就够，存放数字和出现和的次数。

### 字符串

**1.找出第一个匹配的下标**

​		1.可以用定义好的接口

```java
return 寻找.indexOf(被寻找)
```

**2.反转字符串中的单词**

​		1.如果是包含空格的String，去反转每个单词,如何去找到空格之前的单词

```java
int start = 0
end = start + 1;
while(start < end){
	while(start < end && end != ' ');
		end++;
}
```

### 二叉树

​	1.**如果递归逻辑汇中传入的是左右子树，例如root.left/root.right，那么递归的终止条件来判断root即可。**

​	2.**前序求深度，后续求高度**

​	3.**如果判断条件中有root == null，紧挨着下面的判断条件中还有root.left == null 或者root.right == null,说明节点就走到root   			（路径总和）。**

**1.反转二叉树**：

​		1.设计一个用来反转树的方法。

**2.对称二叉树**

​		1.判断左子树的左节点和右子树的右节点。

​		2.判断左子树的右节点和右子树的左节点。

**3.最小深度**

```java
//比最大深度多了两个if判断条件
if(root.left == null) return rightDepth+1;
if(root.right == null) return leftDepth + 1;
return Math.min(leftDepth,rightDepth) + 1;
```

**4.平衡二叉树、最大深度、最小深度、完全二叉树节点个数模板**

```java
if(root == null) return 0;
int left = method(root.left);
//具体逻辑
int right = method(root.right);
//具体逻辑
return Math.max/min(left,right) + 1;
```

**5.二叉树的路径遍历**

​		1.中左右

​		2.回溯思想

```java
search()
path.add(root)
if(root.left == null && root.right == null)
   	result.add()
if(root.left != null)
    search();
	path.remove()
if(root.right != null)
    search();
	path.remove()
```

**6.左叶子之和**

​		1.重点是如何找到左叶子（左右中，不管怎么先把递归的遍历顺序找出来）

```java
if(root.left != null && root.left.left == null && root.left.right == null)//表示通过父节点找到左叶子节点
```

**7.找左叶子节点**

​		1.用层序遍历简单，把之前的层序遍历节点稍作改动，while（len>0)改成for循环，目的是利用i == 0找第一个弹出的值

```java
for(int i = 0;i < len;i++){
    if(i == 0){
        res = temp.val;//不断的更新每一层第一个节点值。
    }
}
```

**8.路径总和**

​		1.按照减法，将目标和依次递减走过的节点。

```java
//三种情况
targetSum -= root.val
1.if(root.left == null && root.right == null)
2.if(root.left != null)
3.if(root.right != null)
```

**9.合并两个二叉树**

​		1.注意在一个二叉树（root1）上重复操作，最终返回这一棵二叉树即可。

#### 二叉搜索树（中序遍历为有序序列）

**1.是否为二叉搜索树**（二插搜索树中的最小绝对差）

​		1.空树也是二叉搜索树。

​		2.双指针解法：重点是怎么去赋值当前节点的前一个节点。

```java
//定义一个TreeNode指针 默认为空
TreeNode pre;
//这里写的是递归函数，刚开始一直递归到左子树的最后一个节点，if第一次不执行，正好将root的值赋给pre
if(pre != null && pre.val >= root.val){
    return false;
}
pre = root;

```

**2.平衡二叉树的众数(中序遍历）**

​		1.一个是计数：

```java
//双指针，pre是前一个指针
TreeNode pre;
if(pre == null || pre.val != root.val){//第一次出现的节点和不相等的节点的count次数都是1
    count = 1;
}else(pre.val == root.val){
    count++;
}
```

​		2.计算出现最多的

```java
if(count == maxCount){
    result.add(root.val);
}else if(count > maxCount){
    result.clear();
    result.add(root.val);
    maxCount = count;
}
```

**3.二叉树的公共祖先**

​		1.后续遍历（单个节点也是自己的公共祖先）

```java
if(root.left != null && root.right == null) return left;//左子树找到了，右子树没找到，返回该节点
if(root.left == null && root.right != null) return right;//同上
```

**4.二插树的修剪，涉及到删除的，条件都是return null**

### 回溯

#### （组合问题：如果结果集中有重复元素，递归条件是i；否则递归条件是i + 1）

**1.电话号码的字母组合**

​		1.首先要定义一个映射的关系。

​		2.不同于普通组合，这是不同集合之间的不同组合

​		3.去看代码

**2.组合求和**（数组中的每一个值在每一个组合中只能使用一次）

​		1.设置boolean类型的used数组来判断之前的是否使用过。

```java
//for循环中的条件
if(i > 0 && nums[i] == nums[i-1] && !used[i])
```

#### 分割问题

**1.分割回文串**

​		1.多了一个判断是否为回文串的过程，不是的话就continue；

**2.ip地址问题**

​		1.设置pointSum，如果  . 的数量等于三，之后在判断最后那一段字符串是否符合要求，符合就加入进去

```java
if(pointSum == 3){
    if(isLegal(s,startIndex,s,length() - 1)){
        result.add(s);
    }
}
```

​		2.逗点的加入；也就是字符串的加入

```java
//字符串是能动态处理，只能截取之后拼接，StringBuilder对象类型的字符串可以动态处理
s = s.substring(0,i + 1) + "." + s.substring(i+1);
```

​		3.求和问题给定字符串的起始节点跟终止节点

```java
int sum = 0;
for(int i = left;i < right;i++){
    sum = sum * 10 +(s.charAt(i) - '0');
}
```

​		4.从字符串charAt出来的数字需要 - '0'才是正常的数字

```java
s = "123456"
System.out.println( (s.charAt(0) - '0') * 10)
    //这样才能输出10
```

#### 子集问题

**1.子集1和子集2**

​		1.子集1不包含重复元素，返回可能的所有子集，解集中不能包含重复元素。

​		2.子集2包含重复元素，返回所有的可能的子集，解集中不能包含重复元素。

```java
对比子集1，子集2的处理方式是首先对数组排序，然后使用used数组。
```

**2.递增子序列**

#### 排列问题（都用不到startIndex）

**1.全排列**

1.不用startIndex来控制不取之前的元素，通过used数组来控制当前元素取过就不再取了。

```java
//注意两个点。一个是没有startIndex，i从0开始的
//另外一个是used数组，标记了就不能再取当前元素了。
for(int i = 0;i < nums.length;i++){
	if(sued[i]){
        continue;
    }
    used[i] = true;
    path.add(nums[i]);
    backtracking(.....);
}
```

### 贪心算法

#### 一般两个变量，一个动态记录最大值，一个用来运算。

**1.分发糖果**

​		1.一个循环条件中控制两个变量

```java
for(int i = 0;i < s.length && start < g.length;i++){
    if(s[i] >= g[start]){
        count++;
        start++;
    }
}
```

**2.摆动序列**

​		1.处理边界序列，所以默认就有一个；即count = 1；

​		2.

```java
if((curDiff > 0 && preDiff <= 0) || (curDiff < 0 && preDiff >=0)){
    count++;
}
```

**3.最大子数组和**

​	1.设置count用于动态的选取初始位置

​	2.如果count <= 0,说明加了一个负数，重置count = 0；（可以加小一点的负数，但是最大值记录的是在没加这个很小的负数的时候的		值）

**4.买卖股票的最佳时机**

​		1.所以只需要将买卖股票的时间转换成每天买卖的利润即可

```java
prices[3] - prices[1] = (prices[3] - prices[2]) + (prices[2] - prices[1])
```

​		2.只记录利润为正的和

**5.跳跃游戏**

​		1.确保覆盖范围能够大于数组的长度即可，在第一个位置的时候 >= nums.length - 1 即可

​		2.不断的更新覆盖范围

```java
for(int i = 0; i< coverRange;i++){
    coverRange = Math.max(coverRange,i + nums[i]);//i + nums[i]的i表示之前已经跳过的步子；
}
```

**6.跳跃游戏II**

​		1.每次在上次能跳到的范围（end）内选择一个能跳的最远的位置（也就是能跳到max_far位置的点）作为下次的起跳点 。

```java
int end = 0;//作为能够跳跃达到的右边界；
int maxPosition = 0;//最为能够跳到的最远的位置
int step;
for(int i = 0;i < nums.length - 1;i++){
    maxPosition = Math.max(maxPosition,i + nums[i]);//找覆盖到的跳跃范围内的最大值；
    if(i == end){//i 走到了i下标对应的覆盖最远位置后；
		end = maxPostion;
        step++;
    }
}
```

**7.加油站**

​	1.计算出总的耗油量，如果是负数，无论如何都不可能走完全称；

​	2.计算每一段路程最小的耗油量

```java
minGas = Math.min(sumGas,minGas)
```

​	如果说最小的耗油量都大于0的话，那么for循环从i = 0开始的，即0号加油站就符合要求

​	3.如果不是的话，那么倒叙循环，不断的计算每一个加油站与最小油耗的和，当把最小油耗变成>=0的时候，遍历到的i就是起始位置。

**8.根据身高重建队列**

**9.射爆气球**

**Arrays.sort重写**

```java
[[1,2],[3,4],[3,5]]
Arrays.sort(person,(a,b) ->{
    return a[0] - b[0];
})
// a - b 表示升序；
// b - a 表示降序；
```

**10.无重叠区间**

​		1.从左到右去遍历，首先按照[a,b]中的b对集合进行从小到大的排序

​		2.初始化右边界为最小值，处理集合中第一个区间

​		3.若上一个区间的右边界小于当前区间的左边界说明没有重叠部分；更新边界

```java
edge = nums[i][1]
```

```java
else{
    count++;
}
```

**11.划分字母区间**

​		1.确定每一个元素出现的最远位置。

​		2.重新遍历字符串，不断更迭出现的最远距离，如果最远距离刚好与遍历的下标i相等。此时做分割。

**12.单调递增的数字**

​		1.需要start确定从哪个位置开始赋值9；

​		2.包括将数字转化成字符串等。

**13.买卖股票的最佳时机含手续费**

### 动态规划

#### 动归五部曲-基础

```java
1.确定dp数组下标及其含义
2.确定递推公式
3.dp数组如何初始化
4.确定遍历顺序
5.举例推导dp数组
```

```
1.这道题目举例推导状态转移公式了吗？？？
2.打印dp数组的日志了吗？？
3.打印出来的dp日志和我的一样吗？？？
```

**1.最小花费爬楼梯**

​		1.dp数组的长度是length + 1，+1代表走到楼顶。

**2.整数拆分**

​		1.拆成相似的数的时候乘积最大（数学证明）

**3.不同的二插搜索树**

​		1.给定一个数字n，确定搜索树个数

​		2.dp[i] 对应的是i个节点的搜索树个数有多少

​		3.以j为头结点，遍历i

```java
dp[0] = 1,dp[1] = 1;
for(int i = 2;i <= n;i++){
    //j代表从1-i个数中选取的不同的数当头结点，=的时候表示右子树是空的情况
    for(int j = 1;j <= i;j++){
        //j-1因为搜索树左子树都比头结点小，i-j代表右子树，因为右子树节点值都比头结点大
        dp[i] += dp[j-1]*dp[i-j];
    }
}
```

#### 0-1背包问题

![image-20221209210258910](力扣.assets/image-20221209210258910.png)

**1.0-1背包就是有n中物品，每种物品只有一个**

**2.完全背包是有n中物品，每种物品有无数个**

**3.多重背包是有n种物品，每种物品个数各不相同**

```java
//初始化问题
//递推公式及遍历顺序
for(int i = 1;i <= weight.length;i++){
    for(int j = 1;j <= bagSize;j++){
        if(j < weight[i-1]){
            dp[i][j] = dp[i-1][j];
        }else{
            dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-weight[i-1] + value[i]]);
        }
    }
}
```

**1.最后一块石头的重量**

​		1.将石头总和分成两堆，其中一堆作为背包，石头的重量跟价值都是数组中元素，求dp[j]

```java
//最终结果
result = sum - dp[target] - [target]
```

**2.目标和**

​		1.给定nums[]和target；

​		2.数组里肯定有两部分left - right = target；还有一部分是固定的 left+right = sum；整理得到left = （sum + target) / 2;

​			所以题意可以理解为，给定一个left背包，有多少种组合方式能将该背包装满。

​		3.装满背包方式的递推公式为 dp[j] = dp[j-nums[i]]；所以总的方式有dp[j] += dp[j-nums[i]]; 

**1和0**

#### 完全背包问题

```java
//与0-1背包的区别
0-1：
for(int i = 0;i < weight.length;i++){
    for(int j = bagSize;j >= weight[i];j--){
        dp[j] = Math.max(dp[j],dp[j-weight[i]] + value[i]);
    }
}
//完全背包
for(int i = 0;i < weight.length;i++){
    for(int j = weight[i];j <= bagSize;j++){
        dp[i] = Math.max(dp[j],dp[j-weight[i]] + value[i]);
    }
}
//应用方面求背包最大价值
dp[j] = Math.max(dp[j],dp[j-weight[i]] + value[i]);
//应用方面求装满背包有多少中方法
dp[j] += dp[j-weight[i]];

```

#### 买卖股票问题：

**1.买卖股票的最佳时机(只允许一次交易）**

​		1.股票问题初始化dp数组为二维状态（持有股票、不持有股票）

```java
int[][] dp = new int[len][2];
//持有股票:dp[i-1][0]是指前一天也可能持有，今天没买入而已，另外一种情况是前一天没有，当天买入，花掉了prices[i]
dp[i][0] = Math.max(dp[i-1][0],-prices[i]);
//不持有股票:
dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0] + prices[i]);
```

**2.买卖股票的最佳时机（允许多次交易）**

​		1.与上面唯一的不同点是

```java
//持有股票
dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1] - prices[i]);
```

**3.买卖股票的最佳时机（至多允许两次交易）**

**4.买卖股票的最佳时机IV**

**5.买卖股票的最佳时机含冷冻期**

**6.买卖股票的最佳时机含手续费**

```java
//初始化
dp[0][0] = -prices[i]
//递推公式
dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1] - prices[i]);
dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0] + prices - fee);
```



#### 子序列问题

1.**最长递增子序列**

​		1.两层for循环，dp[i] 表示以i为末尾的最长子序列 **长度**

```java
//初始化dp[] 全为1
for(int i = 0;i < dp.length;i++){
    for(int j = 0;j < i;j++){
        dp[i] = Math.max(dp[i],dp[j] + 1);
    }
}
//遍历dp，返回最大值。
```

**2.最长重复子数组、最长公共子序列(不相交的线）**

​		1.最长重复子数组，数组元素之间必须相连，找到最长的公共部分，如：[1,2,3,2,1]和[3,2,1,4,7]公共部分 **[3,2,1]**

​		2.最长公共子序列，元素之间可以不必相连，找出最长的公共部分，如："a,b,c,d,e"和"a,c,e"公共部分 **a,c,e**

```java
//1.递推公式
if(nums[i-1] == nums[j-1]){
    dp[i][j] = dp[i-1][j-1] + 1;
}
//2.递推公式
if(ch[i-1] == ch[j-1]){
    dp[i][j] = dp[i-1][j-1] + 1;
}
else{
    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
}
```

**3.判断子序列**

​		1.跟求最长公共子序列套路一样，但是在s[i-1] != t[j-1]的时候，因为t字符串的长度是大于s的，所以t要删除当前的t[i-1]

```java
如果删除t[t-1],则dp[i][j] 就要由dp[i-1] 和 dp[j-2]决定。即dp[i][j] = d[i][j-1]
if(s[i-1] == t[i-1]){
    dp[i][j] = dp[i-1][j-1] + 1;
}else{
    dp[i][j] = dp[i][j-1];
}
//最后遍历dp数组找出最长子序列的值看看是否与s.length()相等；
```

**4.不同的子序列**

**5.两个字符串的删除操作**

**6.字符串中有多少个回文子串**

```java
for(int i = len -1;i >= 0;i--){
    for(int j = i;j < len;j++){
        if(str[i] == str[j]){
            if(j -i >= 1){
                dp[i][j] = true;
                count++;
            }else if(dp[i+1][j-1]{
             	dp[i][j] = true;
                count++;
            }
        }
    }
}
```

## 代码随想录规律总结

### 动态规划

#### 1.整数拆分

​		

```java
for(int i = 3;i <= n;i++){
    for(int j = 1;j <i;j++){
		dp[i] = Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j]));   
    }
}
//j是内层递增，再加上一个dp[i]做Math.max是因为之前可能计算得到一个值，加进去重新做判断最大值
```

#### 2.不同的二插搜索树

```java
for(int i = 2;i < n+1;i++){
    for(int j = 1;j <= i;j++){
        dp[i] += dp[j-1] * dp[i-j];
    }
}
//j <= i必须要等于，当等于的时候就只包含左子树或者只包含右子树；j-1是指左子树，i-j是指右子树。
```

#### 0-1背包(理论)

```java
//dp[i][j]:从下标0-i的物品里任意取，放进容量为j的背包，最大价值是多少(物品不可重复使用)
weight{}
value{}
bagSize = n
for(int i = 0;i < weight.length;i++){
    for(int j = bagSize;j >=weight[i];j--){
        dp[j] = Math.max(dp[j],dp[j-wight[i]] + value[i]);
    }
}
```

#### 目标和

```java
//分成两组，left - right = target;left + right = sum,
1.int temp = (sum + target) / 2;
2.if(temp % 2 == 1) return 0;
3.if(temp < 0) temp = -temp; //[100] target = -200,temp = -100;dp数组没法初始化
4.dp[j] += dp[j-nums[i]];
```



#### 0-1背包应用

##### 最大价值（分割等和子集，最后一块石头的重量）

```java
dp[j] = Math.max(dp[j],dp[j - weight[i]] + value[i]);
```

##### 有多少种方法（目标和）

```java
dp[j] += dp[j-nums[i]];
```



#### 完全背包（理论）

```java
//物品可以使用多次
for(int i = 0;i < nums.length;i++){
    for(int j = weight[i];j <= bageSize;j++){
        dp[j] = Math.max(dp[j],dp[j - weight[i]] + value[i]);
    }
}
```

##### 零钱兑换II

```java
for(int i = 0;i < nums.length;i++){
    for(int j = nums[i];j <= bageSize;j++){
        dp[j] += dp[j - nums[i]];
    }
}
```

##### 组合总和IV（排列）（有if条件）

###### 先遍历背包在遍历物品时要加判断条件，判断背包容量是否大于物品容量

```java
//排列问题，先遍历背包，再遍历物品
for(int i = 0;i < bageSize + 1;i++){
    for(int j = 0;j < num.length;j++){
        if(i >= nums[j]){
            dp[i] += dp[i - nums[j]];
        }
    }
}
```

##### 零钱兑换（有if条件）

```java
//初始化 dp[0] = 0;其余的初始化成最大值，因为后面要求Math.min不然会被0覆盖掉
//凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]
for(int i = 0;i < coins.length;i++){
    for(int j = coins[i];j < coins.length + 1；j++){
        if(dp[j - coins[i]] != max){
            dp[j] = Math.min(dp[j],dp[j - coins[i]] + 1)；
        }
    }
    return dp[amount] = max?dp[amount]:max;
}
```

##### 完全平方数（有if条件）

###### 跟零钱兑换一模一样

```java
//首先i*i不能大于n
int max = Integer.MAX_VALUE;
for(int i = 1;i*i <=n;i++){
    for(int j = i*i;j <= n;j++){
        if(dp[j - i*i] != max){
            dp[j] = Math.min(dp[j],dp[j-i*i]+1);
        }
    }
}
return dp[n];
```

#### 完全背包应用

![image-20221214204250929](力扣.assets/image-20221214204250929.png)

#### 打家劫舍篇

##### 打家劫舍1

```java
//初始化dp[0] = nums[0],dp[1] = Math.max(nums[0],nums[1]);
dp[i] = Math.max(dp[i-1],dp[i-2] + nums[i]);//[i-1]考虑偷不偷，i偷
```

##### 打家劫舍2

##### 打家劫舍3

#### 买卖股票的最佳时机含手续费

```java
//创建二维数组，dp[i][0]表示持有股票，fp[i][1]表示不持有股票
//初始化 dp[0][0] = - prices[i];
for(int i = 1;i < len;i++){
    dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1] - prices[i]);
    dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0] + prices[i] - fee);
}
```



#### 序列问题

##### 最长上升子序列

```java
//两层for循环；dp[i] 以i为结尾的最长子序列的长度是多少
//递推公式
dp[i] = Math.max(dp[i],dp[j] + 1);
```

##### 最长 **连续**  递增序列

```java
//一层for循环就可以 dp[i] 以i为结尾的最长子序列的长度是多少
//递推公式
if(nums[i] > nums[i-1]){
    dp[i] = dp[i-1] + 1;
}else{
    dp[i] = 1;
}
```

##### 最长重复子数组

```java
//两层for循环；二维数组
for(int i = 1;i < len +1;i++){
    for(int j = 1;j < len;j++){
       	if(A[i-1] == B[j-1]){
            dp[i][j] = dp[i-1][j-1]+1;
        } 
    }
}
```

<img src="力扣.assets/image-20221215094226620.png" alt="image-20221215094226620" style="zoom: 50%;" />

##### 最长公共子序列

###### 与最长重复子数组一样，多了一个不相等的条件//所以最后返回的是最后一个位置的元素

```java
//两层for循环；二维数组
if(A[i-1] == B[j-1]){
    dp[i][j] = dp[i-1][j-1]+1;
}else{
    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
}
```

##### 最大子序和

```java
dp[i] = Math.max(nums[i],dp[i-1] + nums[i]);
```

##### 判断子序列

###### 判断A是否为B的子序列，多了一个不相等的情况，不相等将B中的元素删除掉，最终判断最长子序列与A的长度是否相同。

```java
if(A[i-1] == B[j-1]){
    dp[i][j] = dp[i-1][j-1]+1;
}else{
    dp[i][j] = dp[i][j-1];
}
```

#### 回文子串问题

##### 回文串都是初始化的boolean数组，求长度不是

##### 回文子串的遍历顺序都是i从下到上，j从左到右

##### 回文子串连续，回文子序列不连续

```java
dp[i][j]表示范围区间[i,j]内是否为回文串
for(int i = len - 1;i >= 0;i++){
    for(int j = 0;j < len;j++){
        if(str[i] == str[j]){
            if(j - i <= 1){
                count++;
                dp[i][j] = true;
            }else if(dp[i+1][j-1]){
                count++;
                dp[i][j] = true;
            }
        }
    }
}
```

#### 最长回文子序列

##### 与回文子串不同的是，j从i+1开始

```java
for(int i = len -1;i >= 0;i--){
    for(int j = i+1;j<len;j++){
        if(str[i] == str[j]){
            dp[i][j] = dp[i+1][j-1]+2;
        }else{
            dp[i][j] = Math.max(dp[i+1][j],dp[i][j-1]);
        }
    }
}
```

<img src="力扣.assets/image-20221215132050324.png" alt="image-20221215132050324" style="zoom:50%;" />

### 二叉树

#### 二叉树的递归回溯

```java
if(root.left == null && root.right == null){
    ......
}
if(root.left != null){
    backtracing();
    ....
}
if(root.right != null){
    backtracing();
    ....
}
```

### 回溯算法

```java
if(i > 0 && nums[i] == nums[i-1] && used[i-1])
// used[i-1] == true 或者 used[i-1] 表示为使用过，树枝去重
// used[i-1] == false 或者 !used[i-1] 表示未使用过，树层去重
```

## 力扣算法学习计划

**1.轮转数组**

```java
1.数组赋值数学问题
    arr[(i+k) % n] = nums[i];

2.数组拷贝
    System.copyarray(arr,0,nums,0,n);
```

**2.移动零（双指针）**

```java
int j = 0;
if(nums[i] != 0){
   nums[j++] = nums[i]; 
}
```





